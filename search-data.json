[{"title":"115 特殊選才","path":"2025/12/10/115-special-selection/","content":"學校 科系 一階分數 二階分數 加權總分 錄取情況 心得 清華大學 不分 75.00/92.00 不錄取 - 不錄取 清華大學 資工 89.25/85.00 84.75 86.10 備取16 △ 連結 陽明交大 百川 79.98/83.37 不錄取 - 不錄取 陽明交大 資工 86.00/89.00 不錄取 - 不錄取 成功大學 資工 88.00 47.61 55.69 不錄取 中央大學 資工 87.74/88.89 不錄取 - 不錄取 中山大學 資工 82.00 85.33 84.33/85.87 備取1 △ 連結 中興大學 資工 連結 中正大學 紫荊 81.00/84.00 不錄取 - 不錄取 台灣師範大學 資工 85.71/82.14 沒去（撞成大） - 不錄取 政治大學 資科 逢甲大學 資工 89.33/82.30 92.60 182.58/178.66 正取 1 連結 元智大學 資工 淡江大學 資工 連結 高雄大學 資工 86.67/00.00 90.67 88.67 正取 3 連結 嘉義大學 資工 暨南大學 資工 連結 台南大學 資工 89.00 84.48 86.74/84.15 正取 1 連結 如果有門檻的話會寫（我的分數/門檻） △：等待備上 √：已備上","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才"]},{"title":"115 特殊選材：逢甲資工","path":"2025/12/10/fcu-csie/","content":"面試流程與方法 逢甲資工採用個人面試形式，一位考生對三位教授。 報到與準備流程： 報到後先在休息室等候 面試開始前約 15 分鐘，助教會點名並帶至面試教室門口等待 考生配有一對桌椅 教室配置: 時間管控: 每位考生至多 5 分鐘（自我介紹1分鐘，我就簡短講講） 助教在教室外面負責計時，4分鐘、5分鐘時會敲門 面試問答 Q1：APCS 是不是第一次達到 我：不是，我嘗試了很多次。 教授：那你在這過程是怎麼變強的？ 我：要考高分首先要學習的就是把大問題拆解成小問題，比如說把測資以圖形的方式畫出來，在觀察要用什麼演算法去實做。 Q2：你已經有大二的水準了，那你有遇到什麼困難嘛？ 我：要學習新演算法的時候，可能不夠熟練，所以需要透過不斷的刷題，刷各種類型的題目，讓演算法可以更加的熟練。 教授：你會透過什麼方式更深入了解演算法？ 我：我有時候會去網路上查影片，像是有人會演示這個演算法的過程，讓我可以更加熟練演算法的過程。 Q3：你會用 AI 來輔助你嘛 我：我比較少用 AI 來刷題。 教授：比較少的原因是什麼？ 我：因為我喜歡自己推理的過程。 Q4：我看你的成績有不及格得，是不是因為你把時間都花在寫程式上面了 我：在高一時，我花了較多時間讀學科的內容，升上高二後我就主要花在讀數學上面了。 教授：因為我們還是要教會其他同學，不能因為你的天賦比較超前，就跟著你的進度走，那如果你能夠進來的話，你會怎麼來處理？ 我：那我可能可以透過課程時間來教其他同學之類的。 教授：那以後可以請你來當助教了，哈哈哈。 心得 感覺是進去聊天的哈哈，但聽說教授會笑笑的把你刷掉，有點小恐怖。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","逢甲大學","資工"]},{"title":"115 特殊選材：中興資工","path":"2025/12/10/nchu-csie/","content":"面試流程與方法 中興資工採用個人面試形式，一位考生對三位教授。 報到與準備流程： 報到後先在休息室等候 面試開始前約 10 分鐘，助教會點名並帶至面試教室 考生配有一對桌椅 教室配置: 時間管控: 每位考生至多 5 分鐘（自我介紹1分鐘） 有一個計時器在計時 4、5 分鐘會各響鈴一次 面試問答 Q1：你的 OS 的定義是什麼？是可以從頭開啟嗎？ 我：對，就是從頭開始。 教授：架構是什麼？ 我：RISC-V 架構。 教授：所以你不是一般的 PC 啦齁？ 我：就是用 C 語言，然後直接從 Kernel 開始做，然後做到外面 User Space 這樣子。 Q2：OS 功能實作狀況 我：就是目前就是簡易的基本功能，比如說 VirtIO、Scheduler、Virtual Memory 這樣子。 Q3：你的未來規劃 我：就是我目前大學後我想要學就是類似 RAG 這種東西。然後讓 LLM 直接跑在我的 OS 上面。可以做到那種小型的板子之類的，然後讓它跑在上面這樣子。 教授：最近改動的東西太多了，所以你大學念完應該沒有 RAG 了，那你自己進到大學後你還有想做什麼事情？ 我：像是演算法方面，我會想要參加更多的競賽，像是 ICPC 等等。因為我自己有演算法方面專長。那作業系統可能可以學更多的功能了，就是自己實作出來這樣。因為我看你們的系所介紹也有說什麼作業系統實驗這種課程。 Q4：考演算法 教授：那你剛剛說你算演算法專長嗎？我出個基礎題目，你從你家到中興大學，那你有全國的交通班表，請問你要用什麼演算法找一個最快的做法？ 我：我會用 Dijkstra。 教授：那如果有負權邊呢？ 我：我記得要看有沒有負環…（被打斷） 教授：所以是啥演算法？ 我：這我好像還沒學過。 心得 哇勒，忘記那個演算法叫啥名字了，然後我好像時間還沒到就提早出來了。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","中興大學"]},{"title":"115 特殊選材：暨南資工","path":"2025/12/10/ncnu-csie/","content":"面試流程與方法 暨南資工採用個人面試形式，一位考生對兩位教授，並且分成兩關面試。 報到與準備流程： 報到後先在休息區等候 面試開始前約 3 分鐘，助教會點名並帶至面試教室門口等待 分成兩關，第一關偏聊天的，第二關是簡報自我介紹，然後會問你專業的問題 第一關 教室配置: 時間管控: 每位考生至多 5 分鐘（自我介紹1分鐘，我就簡短講講） 可是好像沒在計時的 面試問答 Q1：什麼時候開始學習資訊相關的東西？ 我：大概是國中會考後。 教授：你是自己有興趣，還是有誰帶你做？ 我：在國中資訊課我就對程式相關的感興趣了。 教授：阿你有跟誰一起玩嘛？ 我：我有時候會找學校的朋友一起玩。 Q2：未來學習規劃？ 我：第一個方面是演算法嘛，我想要參加更多的競賽，像是 ICPC 等等，然後我同時也想要學 AI 相關的東西，因為我目前的能力還沒辦法讓 LLM 直接跑到我的 OS 上面，所以我想要學一個叫 RAG 的東西，讓 LLM 可以跑在我的小型 OS 上面。 教授：什麼小型 OS？ 我：就是自己做的 OS。 Q3：你的 OS 可以幹啥？ 我：我有做 Scheduler、Page Table、VirtIO 等功能。 Q4：你喜歡埔里嘛？ 我：我覺得他在日月潭附近，環境很好，放假也可以去玩。 教授：其實日月潭離這邊還有半個小時的車程。 我：感覺環境就挺好的。 教授：你是台北人嘛？ 我：對啊。 教授：阿你到時後來這邊會不會不習慣，我們以前有些同事剛過來晚上睡不著，因為都是聽到青蛙叫。 Q5：你有報什麼學校？科系呢？ 我：我都報資訊相關的，有清交成、中字輩之類的。 教授：那你為啥想報暨南？ 我：當時我聽到我爸說，他朋友是暨南畢業的，而且他說環境不錯、老師人也很好，所以我想說來試試看。 Q6：家裡有相關的產業嘛？ 我：我爸是做資訊相關的。 教授：那你會去問他問題嘛？ 我：作業系統可能會去問他相關的問題，演算法就是靠自己在網路上找相關的資料。 Q7：那是爸爸主動來教你，還是你自己去問他的？ 我：就比如說，寫作業系統時可能會遇到不懂的程式碼，然後我就會自己去網路上找圖表之類的東西，然後自己解讀，如果還是看不懂，再去詢問他。 Q8：看你英文、數學成績沒有很好？ 我：我覺得我數學能力挺好的，因為我每次段考都可以高平均 10 幾甚至20分。 教授：那你英文能力打算怎麼補強？ 我：我現在會練習多閱讀英文，像是演算法刷題，我會多刷一點 Codeforces、Atcoder 等網站的題目。 第二關 教室配置: 時間管控: 每位考生至多 5 分鐘（自我介紹2分鐘） 有在計時，但好像超過一點點 面試問答 Q1：你的 Scheduler 讓多個 Process 之間是怎麼去做切換的？ 我：就是目前在跑的 Process 會調用一個叫 yield 的函式，然後會跳到 Context Switch 去做些換。 Q2：解釋一下什麼是 System Call 我：System Call 就是可以讓 User Space 去跟 Kernel Space 去做溝通。他是透過一個 ecall 的指令，打入 Kernel 讓他中斷，然後 Kernel 就是會去判斷中斷原因是啥，如果是 System Call 就會去做相關的動作。然後這樣做的原因是因為 User 不能隨便去存取 Kernel 的東西嘛，所以它會去透過 System Call 的指令去問 Kernel 說可不可以做這件事。 Q3：你是怎麼學習的？ 我：作業系統方面我就是會去網路上查了很多的教材，比如說《OS in 1000 lines》和恐龍本等等。 教授：你背後沒有特別找人指導嗎？還是都是靠自己學？ 我：系統方面我可能像剛剛說的上網查，然後如果真的不會，就是網路上查不到就會有可能會去問我爸這樣子。 教授：所以爸爸是資訊相關工程師？ 我：對。 Q4：看你簡報裡寫了很多的演算法，你挑一種來解釋 我：DSU 主要是用來處理集合的合併跟查詢問題。我們可以把它做成一個小的樹，每個點都會有一個樹。然後我們就是如果這兩個點要合併的話呢，我們就把小棵的樹合併到大棵的樹上面。每次查詢我們就把子節點連接到它的祖先下面。那這樣子我們查詢它們兩個是不是連通的時候，我們就可以時間複雜度做到反阿克曼函數。 心得 感覺暨南教授人都很不錯，而且問的問題都有水準的，喔然後，第二關面試的教室超級超級大的。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","暨南大學"]},{"title":"115 特殊選材：中山資工","path":"2025/12/10/nsysu-csie/","content":"面試流程與方法 中山資工採用團體面試形式,分為 13:30 和 15:10 兩個場次,每場次 12 位考生。 報到與準備流程: 報到後先在休息室等候 面試開始前約 15 分鐘,助教會點名並帶隊至面試教室 每位考生配有一張長桌,不提供延長線等設備 有約 10 分鐘的準備時間設置個人電腦與簡報 教室配置: 時間管控: 每位考生至多 6 分鐘(5 分鐘簡報 + 1 分鐘問答) 助教負責計時,剩餘 1 分鐘時會舉牌提醒 時間到立即結束,教授會直接移動至下一位考生的位置 面試問答 面試的問題都是根據你自我介紹的東西去做提問 Q1：專題有在實體裝置上運行嗎? 我：目前階段是在電腦上進行模擬,尚未移植到實體裝置。 Q2：DSU(Disjoint Set Union)的實作方法? 我：DSU是把原本圖… 教授：我問的是實做方法 我：將較小的樹合併到較大的樹下,以降低時間複雜度。 教授：那你有實做過這個演算法嘛 我：有 Q3：OS 整合 LLM 的優勢為何? 我的回答：升上大學後,我計劃深入學習 AI 應用,讓 LLM 不僅僅運行在 host 端,而是能直接在我開發的 OS 上執行…(時間到) 心得 我是第一個講的，完全沒辦法先參考其他人的再做修改，雖然感覺時間也不夠修改就是了，但第一個講完其實也蠻爽的，後面都在看其他人怎麼講。 事實證明：穿短褲並不影響錄取。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","中山大學"]},{"title":"115 特殊選材：清華資工","path":"2025/12/10/nthu-csie/","content":"面試流程與方法 清華資工採用個人面試形式，一位考生對兩位教授，並且分成兩關面試。 報到與準備流程： 報到後先在休息區等候 面試開始前約 5 分鐘，助教會點名並帶至面試教室門口等待 分成兩關，第一關偏聊天的，第二關是考演算法的 第一關 教室配置: 時間管控: 每位考生至多 10 分鐘（自我介紹 5 分鐘，用投影片講） 應該助教會在外面計時，當時沒太注意 面試問答 Q1：那我先問一下，因為你有提到你這個學科能力競賽台北市有佳作，那是最近的事嗎？ 我：對啊最近幾個月的。 教授：那名次大概是多少？ 我：第 41 名 Q2：所以你同時在玩競程跟 OS 其實是還蠻少見的，那我剛剛在看你的備審資料，我看到你爸爸好像也是做類似的東西，那在這上面你是有跟他討論嗎？ 我：就是在寫 OS 時，那時候在寫 Page Table 的時候，因為 Page Table 是要虛擬轉實體，這個過程感覺很抽象。那我有找網路上的很多圖去解讀，再跟他講解一遍以此來確認我的理解是不是對的。 Q3：你平常上學的時間分配？ 我：我上課的話，可能學校段考前讀一下書，剩下時間可能都會多花在演算法或是作業系統。 教授：所以你的作業系統和演算法應該都是用 C 寫的？ 我：我競程是用 C++ 寫的。 Q4：在你簡單的 OS 上面跑 LLM。所以 Host 端這個它到底是在？ 我：這個目前我是實作透過 API 去 Call 它，因為我現在的能力還沒有學到 AI 底層。那我那時候的想法是說，看我不可以學類似 RAG 的東西，那我可以把模型真的跑在我的 OS 上面，這樣就可以實作出真正的就不用透過 API 這樣。 Q5：這樣跟直接在 User 去 Call API 有啥差別嘛？ 我：這樣我可以從底層開始實做，像是我所說的做成小裝置，可以從底層去處理排程相關的問題。 Q6：為啥想走特殊選才？ 我：因為我這個方面專長我自己也很感興趣的，那我就想說可以透過這個管道去試試看。 教授：那你有報其他學校嘛？ 我：有啊。 教授：那你成大有上嘛？ 我：有進二階。 第二關 教室配置: 時間管控: 每位考生至多 10 分鐘 外面會計時，8分鐘敲門，10分鐘開門 考演算法 桌面上擺了好幾個信封，每個信封有一道題目，用抽的。 Q1：DSU倒建邊 1給定一個連通圖，並按照某個順序刪除邊，求什麼時候1與v不連通？ Q2：最小生成樹 1給定每兩點之間的距離，要把這些點分成 k 組，求任兩組之間最小距離最大化是多少？ Q3：貪心 1給定一個棋盤，每個位置上面有一個籌碼（正整數），每次可以移除上下左右任意一條邊，但是移除的邊上籌碼總數不得超過 k，求可不可以把棋盤清空？ 心得 演算法那邊有點崩，一上來就抽到我最不熟的貪心，而且教授沒跟我說可以換一題…，不然前兩題超簡單的。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","清華大學"]},{"title":"115 特殊選材：高雄資工","path":"2025/12/10/nuk-csie/","content":"面試流程與方法 高雄資工採用團體面試形式,每場次 3 位考生。 報到與準備流程: 報到後先在休息室等候 面試開始前約 15 分鐘,助教會點名並帶隊至面試教室 每位考生配有一張椅子。 教室配置: 時間管控: 三位考生總共至多 15 分鐘 助教負責計時,剩餘 1 分鐘時會敲門提醒 面試問答 教授前面會有三面白板，每面白板上面都寫了一個問題，需要你去根據它還回答，每個問題都會三個人輪流回答。 白板 1：自我介紹 教授：講你的學校，是不是應屆，還有你是哪裡人。 我：各位教授好，我是郭奕麟，我來自台北的陽明高中，我是應屆畢業生，我來自台北。 白板 2：你的表現 教授：你們一定有資訊相關的成品，舉一個例子，你的目標，負責工作，遇到的困難以及解決方法。 我：我覺得我最大的成品是在 COSCUP 開源人年會上當議程講者，我的專題是在簡易的 OS 上運行 LLM，我的目標是做出能讓 LLM 直接的跑在我的作業系統上面，實做出一個小型的 AI 裝置，我遇到的困難是當時在實做虛擬記憶體時，Page Table 很難的接上，因為虛擬記憶體轉實體記憶體的流程太抽象了，所以我當時用了指令去查詢虛擬位置對應到的實體位置是否正確。 白板 3：讀書計畫 教授：說明你大學時的讀書計畫。 我：我目前主要有兩個規劃，第一個是把演算法方面可以更精進，參加更多的演算法競賽，另一個是學習 AI 相關的知識，讓 LLM 可以真正的運行在我的 OS 上面。 教授提問 Q1：你是用什麼架構的 OS 我：RISC-V的架構。 教授：跑得動嘛？ 我：可以。 教授：阿他是純文字的嘛？ 我：對，就是透過打字跟它對話。 教授提問 Q2：那這應該跟硬體相關的啊？ 我：就是我大學後想要學一個叫 RAG 的東西，我想用他做一個模型，讓它可以真正的跑在我的 OS 上面。 心得 那時候面試超好笑，我自我介紹完，換旁邊的那個人，結果他跟我同一間學校，我超傻眼，在我們學校沒聽到要特資工系的有這人啊","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","高雄大學"]},{"title":"115 特殊選材：台南資工","path":"2025/12/10/nutn-csie/","content":"面試流程與方法 南大資工採用個人面試形式，一位考生對兩位教授。 報到與準備流程： 報到後先在休息室等候 面試開始前約 3 分鐘，助教會點名並帶至面試教室 考生配有一對桌椅 教室配置: 時間管控: 每位考生至多 10 分鐘（沒規定自我介紹時間，我就簡短講講） 助教在教室外面負責計時，時間到會敲門 面試問答 Q1：專案的很多問題 我：忘了說啥了，但回答起來挺順的？ Q2：為啥你的觀念沒有五級，看很多人都是反過來 我：我覺得是因為我把時間大部份都投入到了刷題之中，所以理論方面還是比較薄弱的，這也是我升上大學後需要補強的東西。 Q3：你的未來規劃 我：我目前主要有兩個規劃，第一個是把演算法方面可以更精進，參加更多的演算法競賽，另一個是學習 AI 相關的知識，讓 LLM 可以真正的運行在我的 OS 上面。 Q4：你對使用 AI 寫程式的想法 我：我覺得如果你要使用 AI 來寫程式，我覺得你至少會用這東西，而不是用完就丟上去。 教授：所以你覺得要會這東西，而不是 AI 給你啥就用啥？ 我：對，至少要用基本的判斷能力。 心得 教授問的問題都挺友善的，人感覺也很nice。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","台南大學"]},{"title":"115 特殊選材：淡江資工","path":"2025/12/10/tku-csie/","content":"面試流程與方法 淡江資工採用個人面試形式，一位考生對三位教授。 報到與準備流程： 報到後先在休息室等候 面試開始前約 15 分鐘，助教會點名並帶至面試教室 考生配有一對桌椅 教室配置: 時間管控: 每位考生至多 5 分鐘（自我介紹1分鐘） 不知道有沒有計時，我提前出來了 面試問答 Q1：為什麼想來念淡江 我：主要是因為淡江離家裡比較近。 教授：是住哪裡？ 我：住台北天母那邊。 教授：除了地理上的關係還有什麼特別的原因嗎？ 我：我以前也有朋友也是讀淡江的，他說淡江還不錯，建議我可以來讀看看。 Q2：現在 AI 的工具越來越強大，那你在相關的學習或實作過程中有使用到 AI 工具嗎？ 我：會用到啊。 教授：那是大概什麼時候會用到？ 我：像是可能會請它幫忙查資料之類的，或者是程式碼如果有不懂的地方，可能會用到它的解釋。 教授：那你覺得這樣效果不錯嗎？ 我：我覺得這樣效率比自己慢慢去搜尋快很多。 教授：那會不會擔心有一天它變得更強大，那你寫程式的能力會被它取代？ 我：可是我覺得，因為我現在目前如果嘗試用 AI 寫程式，像是我寫作業系統的 Fork 功能的時候，發現它比較沒有那種全局觀，可能沒辦法同時詳細的看到多個檔案，那這樣可能沒辦法讓它返回到正確的位置，所以後來還是只能靠人工自己去 Debug。 Q3：你有報啥學校 我：報得挺多的。 教授：國立大學那邊有報嗎？ 我：國立就頂大都有報這樣。 教授：你還蠻厲害的，如果以你 5 級分，其實還蠻 OK 的。 心得 教授應該覺得我去亂的，連個原因都說不出來。 教授還跟我說我的書審是他打最高的。","date":"2025-12-10","categories":["特殊選才"],"tags":["特殊選才","資工","淡江大學"]},{"title":"APCS 2025/11 解題紀錄（C++）","path":"2025/11/16/apcs-2025-11/","content":"高級 字母配對 題目連結 思路 此題給定 $k$ 個堆疊（$2\\le k\\le 6$），每個堆疊包含若干物品，每個物品有一個字母標識與分數。每次操作可選擇兩個不同的非空堆疊，若它們的頂部物品字母相同，則同時移除並獲得兩者分數之和。目標是最大化總分數。 採用 DFS + 記憶化搜尋 策略。定義狀態為各堆疊當前已取出的物品數量 $(p_0,p_1,\\ldots,p_{k-1})$，其中 $0\\le p_i\\le n_i$（$n_i$ 為第 $i$ 個堆疊的物品總數）。為了高效儲存與查詢狀態，將多維狀態編碼為單一整數 id： $$\\text{id} = \\sum_{i=0}^{k-1} p_i \\cdot m_i,\\quad m_i = \\prod_{j=0}^{i-1}(n_j+1). $$即以混合進位制（每維的進位基數為 $n_i+1$）將 $(p_0,\\ldots,p_{k-1})$ 壓縮成一個整數。 定義 dp[id] 為從狀態 id 開始（即各堆疊分別已取出 $p_0,\\ldots,p_{k-1}$ 個物品）到結束所能獲得的最大分數。遞推關係為： $$\\text{dp}[\\text{id}] = \\max_{i<j} \\begin{cases} b_i[p_i]+b_j[p_j]+\\text{dp}[\\text{id}'],&\\text{若 }p_i<n_i,p_j<n_j\\text{ 且 }a_i[p_i]=a_j[p_j],\\\\ 0,&\\text{否則（無法配對）}. \\end{cases} $$其中 $\\text{id}'=\\text{id}+m_i+m_j$ 表示同時從堆疊 $i$ 和 $j$ 各取出一個物品後的新狀態；$a_i[p_i]$ 與 $b_i[p_i]$ 分別為堆疊 $i$ 頂部（第 $p_i$ 個）物品的字母與分數。初始狀態為所有 $p_i=0$，即 dfs(0)。 遞迴實作時，對所有可行的堆疊對 $(i,j)$ 檢查頂部字母是否相同，若相同則嘗試取出並遞迴至新狀態；dp[id] 記錄該狀態下所有可行決策的最大值。使用記憶化陣列 dp（初始化為 -1）避免重複計算。 時間 / 空間複雜度： 狀態數：最多有 $\\prod_{i=0}^{k-1}(n_i+1)$ 個狀態。在題目限制下（每個堆疊最多 12 個物品、$k\\le 6$），狀態數上界為 $(12+1)^6=13^6\\approx 4.8\\times 10^6$；實際上題目保證「所有堆疊的物品總數 $\\sum n_i\\le 12$」，故可行狀態數遠小於此值。 單次狀態轉移：對每個狀態枚舉所有堆疊對 $(i,j)$，共 $\\binom{k}{2}\\le\\binom{6}{2}=15$ 對，每對常數時間判斷與轉移，故單狀態時間為 $O(k^2)$。 總時間複雜度：$O\\Big(k^2\\cdot\\prod_{i=0}^{k-1}(n_i+1)\\Big)$，在題目規模下可接受。 空間複雜度：$O\\Big(\\prod_{i=0}^{k-1}(n_i+1)\\Big)$ 用於儲存 dp 陣列。 程式碼 12345678910111213141516171819202122232425262728293031323334#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();vector<vector<char>> a;vector<vector<int>> b;vector<int> n, pos, dp, m;int k;int dfs(int id) &#123; if (dp[id] != -1) return dp[id]; int now = 0; for (int i = 0;i < k;i++) if (pos[i] < n[i]) &#123; for (int j = i + 1;j < k;j++) if (pos[j] < n[j] and a[i][pos[i]] == a[j][pos[j]]) &#123; now = max(now, b[i][pos[i]++] + b[j][pos[j]++] + dfs(id + m[i] + m[j])); pos[i]--, pos[j]--; &#125; &#125; return dp[id] = now;&#125;int main() &#123; IO cin >> k; a.resize(k), b.resize(k), n.resize(k), pos.resize(k), m.resize(k); int t = 1; for (int i = 0;i < k;i++) &#123; cin >> n[i]; a[i].resize(n[i]), b[i].resize(n[i]); for (int j = 0;j < n[i];j++) cin >> a[i][j] >> b[i][j]; m[i] = t; t *= n[i] + 1; &#125; dp.resize(t, -1); cout << dfs(0);&#125; 列印工廠 題目連結 思路 給定 $n$ 個印刷任務（$1\\le n\\le 8$），每個任務 $i$ 有開始時間 $s_i$、截止時間 $d_i$ 與所需時間 $t_i$。任務必須在 $[s_i, d_i]$ 內完成，且執行期間不可中斷。目標是找出一個任務排程順序，使得所有任務都能在截止時間內完成，並且最大化相鄰任務間的最小間隔時間（即所有相鄰任務對的間隔時間都至少為某個固定值 $g$，求 $g$ 的最大值）。 核心策略：枚舉所有可能的任務排列順序（共 $8!=40320$ 種），對每個排列使用二分搜尋找出最大可行的固定間隔 $g$。 演算法流程： 排列枚舉：使用 next_permutation 枚舉所有 $n!$ 種任務排列順序（對陣列 v 先排序，再反覆呼叫 next_permutation 直到回到初始狀態）。 二分搜尋間隔 $g$：對每個排列，在 $[0, 1000]$ 區間內二分搜尋最大可行間隔 $g$。定義「可行」為：按照該排列順序依次執行任務，每兩個任務之間至少休息 $g$ 秒，且所有任務都能在截止時間內完成。 可行性檢查：對固定的 $g$，從頭到尾模擬任務執行： 設 last 為當前時間（初始為 0）。 對排列中的第 $i$ 個任務（$i=0,1,\\ldots,n-1$）： 若 $i>0$，先讓印刷機休息 $g$ 秒：last += g。 更新開始時間為「當前時間」與「任務最早開始時間 $s_i$」的較大值：last = max(last, s[i])。 檢查是否能在截止時間前完成：若 last + t[i] > d[i]，則不可行（can = false）。 更新當前時間為任務結束時間：last += t[i]。 若所有任務都通過檢查，則 $g$ 可行，更新答案 ans = max(ans, g) 並嘗試更大的 $g$（l = m + 1）；否則縮小 $g$（r = m - 1）。 輸出最大值：所有排列檢查完畢後，輸出 ans。 時間 / 空間複雜度： 排列數：$O(n!)$；每個排列需二分搜尋 $O(\\log V)$ 次（$V=1000$ 為時間值域），每次檢查需 $O(n)$；總時間複雜度為 $$O(n! \\cdot n \\log V). $$在 $n\\le 8$ 時，$8!\\cdot 8\\cdot\\log 1000\\approx 8!\\cdot 80\\approx 3.2\\times 10^6$，可接受。 空間用於儲存任務資訊與排列狀態，為 $$O(n). $$ 程式碼 123456789101112131415161718192021222324252627282930313233#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();int main() &#123; IO int n; cin >> n; vector<array<int, 3>> v(n); for (auto &[s, d, t] : v) cin >> s >> d >> t; sort(v.begin(), v.end()); int ans = 0; do &#123; int l = 0, r = 1000; while (l <= r) &#123; int m = (l + r) / 2; int last = 0; bool can = 1; for (int i = 0;i < n;i++) &#123; if (i) last += m; last = max(last, v[i][0]); if (last + v[i][2] > v[i][1]) &#123; can = 0; break; &#125; last += v[i][2]; &#125; if (can) ans = max(ans, m), l = m + 1; else r = m - 1; &#125; &#125; while(next_permutation(v.begin(), v.end())); cout << ans;&#125; 翻來覆去 題目連結 思路 給定長度為 $n$ 的排列 $P$，初始時所有元素從 $p_n$ 到 $p_1$ 依序推入堆疊 $S_2$（$p_n$ 在底、$p_1$ 在頂）。目標是使用兩個堆疊的 push 與 pop 操作將排列排序成遞增順序，並求最少需要多少次 pop 操作。 核心觀察：要輸出遞增序列 $1,2,\\ldots,n$，最佳策略是按順序從 1 到 $n$ 依次取出每個數字。對於當前要取出的數字 $i$，設其在原始排列中的位置為 $p=\\text{pos}[i]$，則需要將該數字從所在堆疊的頂部「挖」出來，過程中會連帶 pop 出擋在它上方的所有元素（這些元素會被推入另一個堆疊）。 資料結構與維護： 堆疊表示：不顯式儲存堆疊內容，而是用區間列表 s1 與 s2 維護兩個堆疊當前擁有的連續區間 $[l,r]$（表示原始排列位置 $l$ 到 $r$ 的元素都在該堆疊）。堆疊頂部對應最後加入的區間；同一堆疊內各區間不重疊。 位置標記：使用 BIT（樹狀陣列） 進行區間加減，維護每個位置屬於哪個堆疊：bit.get(p) 返回 1 表示位置 $p$ 在 $S_2$，返回 0 表示在 $S_1$。初始時所有位置標記為 1（全在 $S_2$）。 演算法流程（按 $i=1,2,\\ldots,n$ 順序處理）： 查詢 $p=\\text{pos}[i]$ 與其所屬堆疊 $t=\\text{bit.get}(p)$（from 為當前堆疊，to 為另一堆疊）。 堆疊頂部調整：若 from 的最頂區間 $[l,r]$ 不包含 $p$（即 $p\\notin[l,r]$），表示該區間整體在 $p$ 的上方，需先將其全部 pop（共 $r-l+1$ 次）並推入 to，同時更新 BIT 標記；重複此步驟直到頂部區間包含 $p$。 取出目標元素：設頂部區間為 $[l,r]$，根據堆疊類型分情況處理： 若 $t=1$（$S_2$，左側為頂）：需 pop 出 $[l,p]$ 共 $p-l+1$ 個元素。若 $l<p$，將左側部分 $[l,p-1]$ 推入 to；若 $p<r$，更新 from 的頂部區間為 $[p+1,r]$，否則移除該區間。 若 $t=0$（$S_1$，右側為頂）：需 pop 出 $[p,r]$ 共 $r-p+1$ 個元素。若 $p<r$，將右側部分 $[p+1,r]$ 推入 to；若 $l<p$，更新 from 的頂部區間為 $[l,p-1]$，否則移除該區間。 累加 pop 次數到 ans。 時間 / 空間複雜度： 每個區間最多被建立與刪除各一次，總區間數 $O(n)$；每次查詢 BIT 與區間加減皆為 $O(\\log n)$；總時間複雜度為 $$O(n\\log n). $$ 空間用於 BIT 與區間列表，為 $$O(n). $$ 程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();struct BIT&#123; int n; vector<int> b; BIT(int n = 0) &#123;init(n);&#125; void init(int x) &#123; n = x + 1; b.assign(n + 2, 0); &#125; void add(int i, int v) &#123; for (;i <= n;i += i & -i) b[i] += v; &#125; void range_add(int l, int r, int v) &#123; if (l <= r) &#123; add(l, v); add(r+1,-v); &#125; &#125; int get(int i) &#123; int s = 0; for (;i;i -= i & -i) s+=b[i]; return s; &#125; // 0=S1, 1=S2&#125;;int main() &#123; IO int n; cin >> n; vector<int> pos(n + 1); for (int i = 1, x;i <= n;i++) &#123; cin >> x; pos[x] = i; &#125; vector<pair<int, int>> s1, s2; s2.push_back(&#123;1, n&#125;); BIT bit(n); bit.range_add(1, n, 1); int ans = 0; for (int i = 1;i <= n;i++) &#123; int p = pos[i], t = bit.get(p); auto &from = (t ? s2 : s1), &to = (t ? s1 : s2); while (1) &#123; auto [l, r] = from.back(); if (l <= p and p <= r) break; ans += r - l + 1; bit.range_add(l, r, t ? -1 : 1); to.push_back(&#123;l, r&#125;); from.pop_back(); &#125; auto [l, r] = from.back(); if (t) &#123; ans += p - l + 1; if (l <= p - 1) &#123; bit.range_add(l, p - 1, -1); to.push_back(&#123;l, p - 1&#125;); &#125; if (p + 1 <= r) from.back().first = p + 1; else from.pop_back(); &#125; else &#123; ans += r - p + 1; if (p + 1 <= r) &#123; bit.range_add(p + 1, r, 1); to.push_back(&#123;p + 1, r&#125;); &#125; if (l <= p - 1) from.back().second = p - 1; else from.pop_back(); &#125; &#125; cout << ans;&#125;","date":"2025-11-16","categories":["APCS"],"tags":["APCS","解題","C++"]},{"title":"APCS 2025/10 解題紀錄（C++）","path":"2025/10/19/apcs-2025-10/","content":"中級 彗星撞擊 題目連結 思路 模擬並逐格更新。初始化 v 為大小 n×m、每格值為 x，並用 have 標記先給定的目標格。對每一個操作（程式中第二個 k 讀入的那批查詢，參數為 a,b,s,d），計算正方形區域 $$i\\in\\left[a-\\frac{s-1}{2},a+\\frac{s-1}{2}\\right],\\qquad j\\in\\left[b-\\frac{s-1}{2},b+\\frac{s-1}{2}\\right], $$（程式以 0-based 索引，遇到超出邊界的 $(i,j)$ 則跳過）。對這個區域做一次掃描：若存在任一格 have[i][j] == 1，則將該區域內所有 have[i][j] 設為 0（表示被移除）；否則對區域內每格執行 v[i][j] -= d（扣除耐久）。此策略嚴格按照題意的「若區域內有目標則移除，否則造成傷害」執行，故最後統計最大值 mx = max(v[i][j])、最小值 mn = min(v[i][j]) 與剩餘目標數 cnt = sum(have[i][j]) 能正確反映最終狀態。 時間/空間複雜度（令第二個輸入的查詢數為 $Q$，單次查詢最大正方形邊長為 $s_{\\max}$： $$\\text{初始化與最後統計} = O(n\\cdot m),\\qquad \\text{每次查詢掃描} = O(\\min(s_{\\max}^2,n\\cdot m)), $$因此總時間複雜度為 $$O\\big(nm + Q\\cdot s_{\\max}^2\\big). $$空間複雜度為 $$O(n\\cdot m) $$ 程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();int main() &#123; int n, m, x; cin >> n >> m >> x; vector<vector<int>> v(n, vector<int>(m, x)); vector<vector<int>> have(n, vector<int>(m)); int k; cin >> k; while (k--) &#123; int a, b; cin >> a >> b; have[a][b]++; &#125; cin >> k; while (k--) &#123; int a, b, s, d; cin >> a >> b >> s >> d; bool flag = 0; for (int i = a - (s - 1) / 2;i <= a + (s - 1) / 2;i++) &#123; for (int j = b - (s - 1) / 2;j <= b + (s - 1) / 2;j++) &#123; if (i < 0 or i >= n or j < 0 or j >= m) continue; if (have[i][j]) &#123; have[i][j] = 0; flag = 1; &#125; &#125; &#125; if (!flag) &#123; for (int i = a - (s - 1) / 2;i <= a + (s - 1) / 2;i++) &#123; for (int j = b - (s - 1) / 2;j <= b + (s - 1) / 2;j++) &#123; if (i < 0 or i >= n or j < 0 or j >= m) continue; v[i][j] -= d; &#125; &#125; &#125; &#125; int mx = 0, mn = INF, cnt = 0; for (int i = 0;i < n;i++) &#123; for (int j = 0;j < m;j++) &#123; cnt += have[i][j]; mx = max(mx, v[i][j]); mn = min(mn, v[i][j]); &#125; &#125; cout << mx << ' ' << mn << ' ' << cnt;&#125; 航空拍照圖 題目連結 思路 以「對矩陣 (a) 做 90° 旋轉並比對」的思路。定義旋轉函數 (f)（將 (a) 順時針旋轉 90°）： $$f(a)_{i,j} = a_{n-1-j,i}, $$其中原矩陣 (a) 的大小為 $(n\\times m)$，則 (f(a)) 的大小為 $(m\\times n)$。演算法依序對 (k=0,1,2,3) 做 90° 旋轉（即反覆套用 (f)）；對於每個旋轉後的矩陣 (a’)，若其大小與目標矩陣 (b) 相同，則計算重合且值相等的格子數： $$\\text{now} = \\sum_{i=0}^{n-1}\\sum_{j=0}^{m-1} \\mathbf{1}\\big(a'_{i,j}=b_{i,j}\\big), $$維護最大重合數 $s=\\max(s,\\text{now})$。最終輸出百分比為整數（向下取整）： $$\\text{ans} = \\left\\lfloor\\frac{100\\cdot s}{n\\cdot m}\\right\\rfloor%\\ . $$時間 / 空間複雜度（以原始 $n\\times m$ 為基準）： 每次旋轉 (f) 建構新矩陣需 $O(nm)$，每次相等性檢查需 $O(nm)$。總共最多做 4 次，故時間複雜度為 $$O(4\\cdot n\\cdot m)=O(nm). $$ 額外空間用於儲存旋轉後的矩陣與原矩陣，空間複雜度為 $$O(nm). $$ 程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();vector<vector<int>> f(vector<vector<int>> a) &#123; int n = a.size(), m = a[0].size(); vector<vector<int>> t(m, vector<int>(n)); for (int i = 0;i < m;i++) &#123; for (int j = 0;j < n;j++) &#123; t[i][j] = a[n - 1 - j][i]; &#125; &#125; return t;&#125;int main() &#123; int n, m; cin >> n >> m; vector<vector<int>> a(n, vector<int>(m)), b(n, vector<int>(m)); for (int i = 0;i < n;i++) &#123; for (int j = 0;j < m;j++) &#123; cin >> a[i][j]; &#125; &#125; for (int i = 0;i < n;i++) &#123; for (int j = 0;j < m;j++) &#123; cin >> b[i][j]; &#125; &#125; int s = 0; for (int k = 0;k < 4;k++) &#123; if (a.size() == b.size() and a[0].size() == b[0].size()) &#123; int now = 0; for (int i = 0;i < n;i++) &#123; for (int j = 0;j < m;j++) &#123; if (a[i][j] == b[i][j]) now++; &#125; &#125; s = max(s, now); &#125; a = f(a); &#125; cout << (100 * s) / (n * m) << '%';&#125; 商品包裝地 題目連結 思路 逐筆讀入長度為 13 的字串 x，將前 12 位分成「奇數位」與「偶數位」兩組（程式以 0-based 索引，條件為 (i+1)%2 判斷奇偶），計算 $$s_1=\\sum_{\\substack{0\\le i\\le 11\\ i\\equiv 0\\pmod{2}}}\\big(x[i]-'0'\\big),\\qquad s_2=\\sum_{\\substack{0\\le i\\le 11\\ i\\equiv 1\\pmod{2}}}\\big(x[i]-'0'\\big). $$將第 13 位記作 $d_{13}=x[12]-'0'$。題目程式中以 $$k=(s_1+3s_2)\\bmod 10 + d_{13} $$判定合法條件 if (k == 0 or k == 10)，其數學意義等價於 $$(s_1+3s_2+d_{13})\\equiv 0\\pmod{10}, $$也就是「前 12 位按奇偶位加權求和，再加上第 13 位，模 10 等於 0」時視為一筆合法資料（符合 ISBN／檢查碼類似的檢核邏輯）。當該筆合法時，把該字串的前三個字元 x.substr(0,3) 當作 key 在 map<string,int> cnt 中計數，並更新 ans = max(ans, cnt[prefix]) 作為目前觀察到的最大頻次。讀完所有輸入後，按 map 的鍵序（由小到大）掃描，遇到 y == ans 即輸出該 prefix 與 ans（程式以第一個符合者輸出，對應於字典序最小的前綴）。 時間 / 空間複雜度： 每筆字串固定做 (12) 次位元相加與常數次數的字串切片／ map 操作：單筆時間為 $O(\\log M)$（M 為目前不同前綴數，因 map 為平衡樹），整體時間為 $$O\\big(n\\log M\\big)\\subseteq O(n\\log n). $$ 空間用於 map 儲存至多 $(M\\le n)$ 個不同前綴，為 $O(M)$。 程式碼 123456789101112131415161718192021222324252627282930#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();int main() &#123; int n; cin >> n; map<string, int> cnt; int ans = 0; while (n--) &#123; string x; cin >> x; int s1 = 0, s2 = 0; for (int i = 0;i < 12;i++) &#123; if ((i + 1) % 2) s1 += x[i] - '0'; else s2 += x[i] - '0'; &#125; int k = (s1 + 3 * s2) % 10 + (x[12] - '0'); if (k == 0 or k == 10) &#123; cnt[x.substr(0, 3)]++; ans = max(ans, cnt[x.substr(0, 3)]); &#125; &#125; for (auto [x, y] : cnt) &#123; if (y == ans) &#123; cout << x << ' ' << ans; return 0; &#125; &#125;&#125;","date":"2025-10-19","categories":["APCS"],"tags":["APCS","解題","C++"]},{"title":"APCS 2025/06 解題紀錄（C++）","path":"2025/09/08/apcs-2025-06/","content":"小心陷阱 題目連結 思路 採直接模擬並嚴格遵循「先移動、後扣血」。初始化 now = k 表示從位置 0 以步長 k 跳到第一個落點；在 while (k > 0) 的每輪，先依 now 是否分別為 x1、x2 的倍數扣除 y1、y2（可同時扣），若仍 k>0，則續行 now += k 進入下一輪。形式化遞推為 $$\\text{now}_t=\\text{now}_{t-1}+k_{t-1},\\qquad k_t = k_{t-1}-y_1\\,[x_1\\mid \\text{now}_t]-y_2\\,[x_2\\mid \\text{now}_t], $$當 $k_t\\le 0$ 停止並輸出 $\\text{now}_t$。不變量為「每輪開頭的 now 等於上一輪完成跳躍的落點」，據此流程與題意等價；時間複雜度為回合數的線性時間。 程式碼 123456789101112131415#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();int main() &#123; int k, x1, y1, x2, y2; cin >> k >> x1 >> y1 >> x2 >> y2; int now = k; while (k > 0) &#123; if (now % x1 == 0) k -= y1; if (now % x2 == 0) k -= y2; now += max(0, k); &#125; cout << now;&#125; 轉盤得分 題目連結 思路 以 pos[j] 表示第 j 個輪盤的總旋轉量；每回合讀入位移 x 後做 pos[j] -= x。對每個直欄 i=0..n-1，以安全索引 $$\\mathrm{idx}(i,j)=\\big((i+\\mathrm{pos}[j]) \\bmod n + n\\big)\\bmod n $$取得 s[j][idx(i,j)]，用陣列 a[26] 統計該欄 m 個字元的頻率，取最大值 MAX 累加至 ans。本質為將每個 s[j] 旋轉 pos[j] 後逐欄取眾數；單回合成本 $O(n\\cdot(m+26))$，總計 $O(k\\cdot n\\cdot(m+26))$。 程式碼 1234567891011121314151617181920212223242526#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();int main() &#123; int m, n, k; cin >> m >> n >> k; vector<string> s(m); for (auto &x : s) cin >> x; vector<int> pos(m, 0); int ans = 0; while (k--) &#123; for (int i = 0; i < m; i++) &#123; int x; cin >> x; pos[i] -= x; &#125; for (int i = 0; i < n; i++) &#123; int a[26] = &#123;&#125;, MAX = 0; for (int j = 0; j < m; j++) &#123; MAX = max(MAX, ++a[s[j][(((i + pos[j]) % n) + n) % n] - 'a']); &#125; ans += MAX; &#125; &#125; cout << ans;&#125; 貪心闖關 題目連結 思路 以嚴格遞減單調棧 st 模擬「較小堆優先被搬空並併入較大堆」：讀入一堆 x 時，只要 st.back() ≤ x，即將 st.back() 全量加到 ans，並合併至 x（x += st.back()）後彈出，直到棧頂 > x 才停止；合併完若 x ≤ t 則把 x 推回 st。全部處理後，再把 st 內殘餘總和加進 ans 即為答案。交換論證可證「先處理較小堆」不劣於任何合法搬運序；每堆至多入棧、出棧各一次，時間複雜度 $O(n)$。 程式碼 12345678910111213141516171819202122#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);#define int long longconst long long INF = numeric_limits<int>::max();signed main() &#123; IO int n, t; cin >> n >> t; vector<int> st; long long ans = 0; for (int i = 0; i < n; i++) &#123; long long x; cin >> x; while (!st.empty() && st.back() <= x) &#123; ans += st.back(); x += st.back(); st.pop_back(); &#125; if (x <= t) st.push_back(x); &#125; for (auto x : st) ans += x; cout << ans;&#125; 分組遊戲 題目連結 思路 二分門檻 m。對固定 m，在鄰接表 v 上僅沿「權重 < m」的邊用 vis + BFS/DFS 計算連通塊數 cnt：任兩點若距離 < m 則必須同組，而不同連通塊間距離皆 $\\ge m$ 可任意合併，故可行條件為 $$f(m)\\;=\\;(\\,\\text{cnt}\\ge k\\,). $$在距離值域以 l..r 二分最大可行 m：若 f(m) 成立則更新 ans=m, l=m+1，否則 r=m-1。單次檢查 $O(n^2)$，總複雜度 $O(n^2\\log V)$（V 為距離值域或不同距離數）。 程式碼 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include <bits/stdc++.h>using namespace std;#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);const long long INF = numeric_limits<int>::max();int n, k;vector<vector<pair<int,int>>> v;bool f(int m) &#123; bitset<505> vis; int cnt = 0; for (int i = 1; i <= n; i++) &#123; if (vis[i]) continue; cnt++; queue<int> q; q.push(i); vis[i] = 1; while (!q.empty()) &#123; int t = q.front(); q.pop(); for (auto [nt, x] : v[t]) &#123; if (vis[nt] || x >= m) continue; vis[nt] = 1; q.push(nt); &#125; &#125; &#125; return cnt >= k;&#125;int main() &#123; IO cin >> n >> k; v.resize(n + 1); int l = INF, r = 0, ans = 0; for (int i = 1; i <= n; i++) &#123; for (int j = 1; j <= n; j++) &#123; int x; cin >> x; if (i != j) v[i].push_back(&#123;j, x&#125;); r = max(r, x); l = min(l, x); &#125; &#125; while (l <= r) &#123; int m = (l + r) / 2; if (f(m)) &#123; ans = m; l = m + 1; &#125; else r = m - 1; &#125; cout << ans;&#125;","date":"2025-09-08","categories":["APCS"],"tags":["APCS","解題","C++"]}]