---
title: APCS 2025/06 解題紀錄（C++）
date: 2025-09-08
updated: 2025-09-08
categories: [APCS]
tags: [APCS, 解題, C++]
toc: true
comments: true
---
# APCS 2025/06 題解

## 1. [小心陷阱](https://zerojudge.tw/ShowProblem?problemid=q836)

### 思路
我們每次都會走 k 步，當 k <= 0 時就結束；所以用 while 迴圈：只要 k > 0 就重複。若現在位置是 x1 或 x2 的倍數，分別讓 k 減去 y1 或 y2。最後輸出的 `now` 就是答案。

### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int main() {
    int k, x1, y1, x2, y2;
    cin >> k >> x1 >> y1 >> x2 >> y2;
    int now = k;
    while (k > 0) {
        if (now % x1 == 0) k -= y1;
        if (now % x2 == 0) k -= y2;
        now += max(0, k);
    }
    cout << now;
}
```

---

## 2. [轉盤得分](https://zerojudge.tw/ShowProblem?problemid=q837)

### 思路

記下每個字串的開始位置，扣掉每次的轉動距離就是新的起點。

> 小提醒（C++）：善用 `(((i + pos[j]) % n) + n) % n` 以避免負數索引造成 RTE。

### 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int main() {
    int m, n, k;
    cin >> m >> n >> k;
    vector<string> s(m);
    for (auto &x : s) cin >> x;
    vector<int> pos(m, 0);
    int ans = 0;
    while (k--) {
        for (int i = 0; i < m; i++) {
            int x; cin >> x;
            pos[i] -= x;
        }
        for (int i = 0; i < n; i++) {
            int a[26] = {}, MAX = 0;
            for (int j = 0; j < m; j++) {
                MAX = max(MAX, ++a[s[j][(((i + pos[j]) % n) + n) % n] - 'a']);
            }
            ans += MAX;
        }
    }
    cout << ans;
}
```

---

## 3. [貪心闖關](https://zerojudge.tw/ShowProblem?problemid=q838)

### 思路

用「嚴格遞減棧」模擬：對每個關卡 `x`，只要棧頂 `w ≤ x`，先把 `w` 加到答案並把 `w` 併入 `x`，持續彈棧直到棧頂 `> x`。若合併後的 `x` 不超過上限 `t`，把它壓回棧。最後把棧中剩餘加總到答案即得結果。

### 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#define int long long
const long long INF = numeric_limits<int>::max();
signed main() {
    IO
    int n, t; cin >> n >> t;
    vector<int> st;
    long long ans = 0;
    for (int i = 0; i < n; i++) {
        long long x; cin >> x;
        while (!st.empty() && st.back() <= x) {
            ans += st.back();
            x += st.back();
            st.pop_back();
        }
        if (x <= t) st.push_back(x);
    }
    for (auto x : st) ans += x;
    cout << ans;
}
```

---

## 4. [分組遊戲](https://zerojudge.tw/ShowProblem?problemid=q839)

### 思路

把距離矩陣視為完全圖；對門檻 `m`，若兩點距離 `< m` 就視為同組。用 BFS/DFS 算連通塊數 `cnt`，若 `cnt ≥ k` 代表可分成至少 `k` 組；對 `m` 二分搜尋求最大可行值。

### 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int n, k;
vector<vector<pair<int,int>>> v;
bool f(int m) {
    bitset<505> vis;
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (vis[i]) continue;
        cnt++;
        queue<int> q; q.push(i); vis[i] = 1;
        while (!q.empty()) {
            int t = q.front(); q.pop();
            for (auto [nt, x] : v[t]) {
                if (vis[nt] || x >= m) continue;
                vis[nt] = 1;
                q.push(nt);
            }
        }
    }
    return cnt >= k;
}
int main() {
    IO
    cin >> n >> k;
    v.resize(n + 1);
    int l = INF, r = 0, ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int x; cin >> x;
            if (i != j) v[i].push_back({j, x});
            r = max(r, x);
            l = min(l, x);
        }
    }
    while (l <= r) {
        int m = (l + r) / 2;
        if (f(m)) { ans = m; l = m + 1; }
        else r = m - 1;
    }
    cout << ans;
}
```
