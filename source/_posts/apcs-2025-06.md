---
title: APCS 2025/06 解題紀錄（C++）
date: 2025-09-08
updated: 2025-09-08
cover: https://i.pinimg.com/736x/f4/5d/f3/f45df3bf76a72e99b51f44e808408e62.jpg
categories: [APCS]
tags: [APCS, 解題, C++]
toc: true
comments: true
---
## 小心陷阱
[題目連結](https://zerojudge.tw/ShowProblem?problemid=q836)

### 思路

從位置 0、生命值 `k` 出發，每回合先以「當前生命 `k`」當步長把位置 `p` 前進到 `p += k`，再依新位置是否為 `x1`、`x2` 的倍數扣除對應生命（可能同時扣）；當 `k ≤ 0` 結束並輸出最後位置。實作上可用 `while (k > 0)` 模擬，你的寫法以 `p`（或 `now`）紀錄位置、每輪結束後才扣血，正好符合題意；正確性來自「先移動後判定扣血」的不變量，複雜度為迴圈次數的線性時間。

### 問題模型
- 位置在一維數線，初始 `p=0`、生命值 `k`。每回合**先跳** `k` 格到新位置，再依新位置是否為 `x1`、`x2` 的倍數扣血（可同時扣）。
- 你的實作使用 `now` 記錄**剛跳完**的落點（初始令 `now = k` 對應第一次從 0 跳 `k` 格），並在每輪：
  1) 依 `now` 判定扣血 `k -= [now % x1==0]*y1 + [now % x2==0]*y2`；  
  2) 若 `k>0`，代表下一回合仍會跳 `k` 格，故更新 `now += k`（等價於 `p += k`）；若 `k<=0`，停止。

### 正確性（不變量）
- **不變量**：每次迴圈的開頭，`now` 恆等於「上回合剛完成跳躍之落點」。因此在該點判定陷阱扣血，即忠實實現「**先移動、後扣血**」的規則。
- 結束時 `k≤0` 而未再位移，輸出最後落點 `now`，與題意一致。

### 複雜度與邊界
- 單純模擬即可。生命值每回合至多扣到 0，最大回合數受 `k` 與陷阱觸發頻率界定。  
- 複雜度 \(O(\text{迴圈次數})\)；由於題目給定的 \(k\) 與倍數條件小，直接模擬最穩妥。  
- 邊界：當某回合 `now` 既非 `x1` 也非 `x2` 的倍數，該輪不扣血，仍正確更新 `now += k`；當 \(x_1\mid \text{now}\) 且 \(x_2\mid \text{now}\) 時扣 \(y_1+y_2\)。

### 公式化描述
令第 \(t\) 輪落點為 \(p_t\)，生命為 \(k_t\)。初始 \(p_0=0,\,k_0=k\)。  
遞推（先移動後扣血）：
\[
p_{t}=p_{t-1}+k_{t-1},\qquad
k_{t}=k_{t-1}-y_1\,[x_1\mid p_t]-y_2\,[x_2\mid p_t].
\]
當 \(k_t\le 0\) 時回傳 \(p_t\)。

### 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int main() {
    int k, x1, y1, x2, y2;
    cin >> k >> x1 >> y1 >> x2 >> y2;
    int now = k;
    while (k > 0) {
        if (now % x1 == 0) k -= y1;
        if (now % x2 == 0) k -= y2;
        now += max(0, k);
    }
    cout << now;
}
```

---

## 轉盤得分
[題目連結](https://zerojudge.tw/ShowProblem?problemid=q837)

### 思路

有 `m` 個長度 `n` 的圓形字串，進行 `k` 回合；每回合先對每個輪盤施加位移（可負），接著對每個位置 `i=0..n-1` 統計該欄 `m` 個字元，取最多者次數累加為本回合得分，最後總分為各回合和。你的作法以陣列 `pos[j]` 記錄每盤「起點偏移」，每回合做 `pos[j] -= shift[j]`，取字元時用安全索引 `((i + pos[j]) % n + n) % n` 避免負數，並以 26 長度計數陣列取最大值；時間約為 `O(k * n * (m+26))`。

### 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int main() {
    int m, n, k;
    cin >> m >> n >> k;
    vector<string> s(m);
    for (auto &x : s) cin >> x;
    vector<int> pos(m, 0);
    int ans = 0;
    while (k--) {
        for (int i = 0; i < m; i++) {
            int x; cin >> x;
            pos[i] -= x;
        }
        for (int i = 0; i < n; i++) {
            int a[26] = {}, MAX = 0;
            for (int j = 0; j < m; j++) {
                MAX = max(MAX, ++a[s[j][(((i + pos[j]) % n) + n) % n] - 'a']);
            }
            ans += MAX;
        }
    }
    cout << ans;
}
```

---

## 貪心闖關
[題目連結](https://zerojudge.tw/ShowProblem?problemid=q838)

### 思路

規則是反覆把某關卡的沙包「全部」搬到右側下一個仍有沙包的關卡（若已是最右則搬出場），問總搬運量。可用「嚴格遞減棧」：對當前 `x`，只要棧頂 `w ≤ x` 就表示會先把 `w` 搬空、其量計入答案並合併到 `x`（`x += w`），連續彈到棧頂 `> x` 為止，再把 `x` 推回維持遞減；最後把棧內剩餘加總到答案。這與題目規則等價（可用交換論證說明先處理較小堆不影響結果），總複雜度 `O(n)`。

### 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#define int long long
const long long INF = numeric_limits<int>::max();
signed main() {
    IO
    int n, t; cin >> n >> t;
    vector<int> st;
    long long ans = 0;
    for (int i = 0; i < n; i++) {
        long long x; cin >> x;
        while (!st.empty() && st.back() <= x) {
            ans += st.back();
            x += st.back();
            st.pop_back();
        }
        if (x <= t) st.push_back(x);
    }
    for (auto x : st) ans += x;
    cout << ans;
}
```

---

## 分組遊戲
[題目連結](https://zerojudge.tw/ShowProblem?problemid=q839)

### 思路

給距離矩陣 `D` 與組數 `k`，希望分組後「不同組之間」的距離中的**最小值**盡量大。設門檻 `m`：把所有距離 `< m` 的點連邊並做連通塊，塊數 `cnt` 代表至少可分成的組數；若 `cnt ≥ k` 則 `m` 可行。因為可行性隨 `m` 單調，可在距離範圍上二分最大可行 `m`；每次檢查用 BFS/DFS 數塊，總複雜度約 `O(n^2 log V)`（`V` 為距離值域或不同距離數）。

### 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int n, k;
vector<vector<pair<int,int>>> v;
bool f(int m) {
    bitset<505> vis;
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (vis[i]) continue;
        cnt++;
        queue<int> q; q.push(i); vis[i] = 1;
        while (!q.empty()) {
            int t = q.front(); q.pop();
            for (auto [nt, x] : v[t]) {
                if (vis[nt] || x >= m) continue;
                vis[nt] = 1;
                q.push(nt);
            }
        }
    }
    return cnt >= k;
}
int main() {
    IO
    cin >> n >> k;
    v.resize(n + 1);
    int l = INF, r = 0, ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int x; cin >> x;
            if (i != j) v[i].push_back({j, x});
            r = max(r, x);
            l = min(l, x);
        }
    }
    while (l <= r) {
        int m = (l + r) / 2;
        if (f(m)) { ans = m; l = m + 1; }
        else r = m - 1;
    }
    cout << ans;
}
```
