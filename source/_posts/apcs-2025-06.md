---
title: APCS 2025/06 解題紀錄（C++）
date: 2025-09-08
updated: 2025-09-08
categories: [APCS]
tags: [APCS, 解題, C++]
toc: true
comments: true
---
# 1. [小心陷阱](https://zerojudge.tw/ShowProblem?problemid=q836)

## 思路

從位置 0、生命值 `k` 出發，每回合先以「當前生命 `k`」當步長把位置 `p` 前進到 `p += k`，再依新位置是否為 `x1`、`x2` 的倍數扣除對應生命（可能同時扣）；當 `k ≤ 0` 結束並輸出最後位置。實作上可用 `while (k > 0)` 模擬，你的寫法以 `p`（或 `now`）紀錄位置、每輪結束後才扣血，正好符合題意；正確性來自「先移動後判定扣血」的不變量，複雜度為迴圈次數的線性時間。

## 程式碼
```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int main() {
    int k, x1, y1, x2, y2;
    cin >> k >> x1 >> y1 >> x2 >> y2;
    int now = k;
    while (k > 0) {
        if (now % x1 == 0) k -= y1;
        if (now % x2 == 0) k -= y2;
        now += max(0, k);
    }
    cout << now;
}
```

---

# 2. [轉盤得分](https://zerojudge.tw/ShowProblem?problemid=q837)

## 思路

有 `m` 個長度 `n` 的圓形字串，進行 `k` 回合；每回合先對每個輪盤施加位移（可負），接著對每個位置 `i=0..n-1` 統計該欄 `m` 個字元，取最多者次數累加為本回合得分，最後總分為各回合和。你的作法以陣列 `pos[j]` 記錄每盤「起點偏移」，每回合做 `pos[j] -= shift[j]`，取字元時用安全索引 `((i + pos[j]) % n + n) % n` 避免負數，並以 26 長度計數陣列取最大值；時間約為 `O(k * n * (m+26))`。

## 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int main() {
    int m, n, k;
    cin >> m >> n >> k;
    vector<string> s(m);
    for (auto &x : s) cin >> x;
    vector<int> pos(m, 0);
    int ans = 0;
    while (k--) {
        for (int i = 0; i < m; i++) {
            int x; cin >> x;
            pos[i] -= x;
        }
        for (int i = 0; i < n; i++) {
            int a[26] = {}, MAX = 0;
            for (int j = 0; j < m; j++) {
                MAX = max(MAX, ++a[s[j][(((i + pos[j]) % n) + n) % n] - 'a']);
            }
            ans += MAX;
        }
    }
    cout << ans;
}
```

---

# 3. [貪心闖關](https://zerojudge.tw/ShowProblem?problemid=q838)

## 思路

規則是反覆把某關卡的沙包「全部」搬到右側下一個仍有沙包的關卡（若已是最右則搬出場），問總搬運量。可用「嚴格遞減棧」：對當前 `x`，只要棧頂 `w ≤ x` 就表示會先把 `w` 搬空、其量計入答案並合併到 `x`（`x += w`），連續彈到棧頂 `> x` 為止，再把 `x` 推回維持遞減；最後把棧內剩餘加總到答案。這與題目規則等價（可用交換論證說明先處理較小堆不影響結果），總複雜度 `O(n)`。

## 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#define int long long
const long long INF = numeric_limits<int>::max();
signed main() {
    IO
    int n, t; cin >> n >> t;
    vector<int> st;
    long long ans = 0;
    for (int i = 0; i < n; i++) {
        long long x; cin >> x;
        while (!st.empty() && st.back() <= x) {
            ans += st.back();
            x += st.back();
            st.pop_back();
        }
        if (x <= t) st.push_back(x);
    }
    for (auto x : st) ans += x;
    cout << ans;
}
```

---

# 4. [分組遊戲](https://zerojudge.tw/ShowProblem?problemid=q839)

## 思路

給距離矩陣 `D` 與組數 `k`，希望分組後「不同組之間」的距離中的**最小值**盡量大。設門檻 `m`：把所有距離 `< m` 的點連邊並做連通塊，塊數 `cnt` 代表至少可分成的組數；若 `cnt ≥ k` 則 `m` 可行。因為可行性隨 `m` 單調，可在距離範圍上二分最大可行 `m`；每次檢查用 BFS/DFS 數塊，總複雜度約 `O(n^2 log V)`（`V` 為距離值域或不同距離數）。

## 程式碼

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
const long long INF = numeric_limits<int>::max();
int n, k;
vector<vector<pair<int,int>>> v;
bool f(int m) {
    bitset<505> vis;
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (vis[i]) continue;
        cnt++;
        queue<int> q; q.push(i); vis[i] = 1;
        while (!q.empty()) {
            int t = q.front(); q.pop();
            for (auto [nt, x] : v[t]) {
                if (vis[nt] || x >= m) continue;
                vis[nt] = 1;
                q.push(nt);
            }
        }
    }
    return cnt >= k;
}
int main() {
    IO
    cin >> n >> k;
    v.resize(n + 1);
    int l = INF, r = 0, ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int x; cin >> x;
            if (i != j) v[i].push_back({j, x});
            r = max(r, x);
            l = min(l, x);
        }
    }
    while (l <= r) {
        int m = (l + r) / 2;
        if (f(m)) { ans = m; l = m + 1; }
        else r = m - 1;
    }
    cout << ans;
}
```
